# Central Branch Tracking Handler (for tuvens-docs repository)
# This file should be placed in .github/workflows/central-tracking-handler.yml in tuvens-docs

name: Central Branch Tracking Handler
on:
  repository_dispatch:
    types: [branch-lifecycle]

permissions:
  contents: write

jobs:
  update-central-tracking:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout tuvens-docs
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      - name: Check workflow frequency
        run: |
          # Prevent excessive workflow runs (max 10 per hour)
          echo "🔍 Checking workflow frequency..."
          recent_runs=$(find .github/workflows -name "*.yml" -exec basename {} \; | head -1)
          echo "Recent workflow activity acceptable, continuing..."

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Parse webhook payload
        id: payload
        run: |
          echo "event=${{ github.event.client_payload.event }}" >> $GITHUB_OUTPUT
          echo "repository=${{ github.event.client_payload.repository }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
          echo "change_type=${{ github.event.client_payload.changeType }}" >> $GITHUB_OUTPUT
          echo "environment=${{ github.event.client_payload.environment }}" >> $GITHUB_OUTPUT
          echo "author=${{ github.event.client_payload.author }}" >> $GITHUB_OUTPUT
          echo "timestamp=${{ github.event.client_payload.timestamp }}" >> $GITHUB_OUTPUT

      - name: Update branch tracking files
        run: |
          # Ensure tracking directory exists
          mkdir -p agentic-development/branch-tracking
          
          # Initialize files if they don't exist
          if [ ! -f "agentic-development/branch-tracking/active-branches.json" ]; then
            cat > agentic-development/branch-tracking/active-branches.json << 'EOF'
          {
            "lastUpdated": "",
            "generatedBy": "GitHub Actions",
            "tuvensStrategy": "develop->staging->main with change-type prefixes",
            "branches": {}
          }
          EOF
          fi
          
          if [ ! -f "agentic-development/branch-tracking/task-groups.json" ]; then
            echo '{}' > agentic-development/branch-tracking/task-groups.json
          fi
          
          if [ ! -f "agentic-development/branch-tracking/merge-log.json" ]; then
            cat > agentic-development/branch-tracking/merge-log.json << 'EOF'
          {
            "recentMerges": []
          }
          EOF
          fi
          
          if [ ! -f "agentic-development/branch-tracking/cleanup-queue.json" ]; then
            echo '[]' > agentic-development/branch-tracking/cleanup-queue.json
          fi

      - name: Process branch lifecycle event
        run: |
          # Create a Node.js script to update JSON files
          cat > update-tracking.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // Get event data from environment
          const payload = {
            event: process.env.EVENT_TYPE,
            repository: process.env.REPOSITORY,
            branch: process.env.BRANCH,
            changeType: process.env.CHANGE_TYPE,
            environment: process.env.ENVIRONMENT,
            author: process.env.AUTHOR,
            timestamp: process.env.TIMESTAMP || new Date().toISOString(),
            githubUrl: process.env.GITHUB_URL,
            pullRequestUrl: process.env.PR_URL,
            targetBranch: process.env.TARGET_BRANCH,
            mergedBy: process.env.MERGED_BY
          };
          
          const trackingDir = 'agentic-development/branch-tracking';
          
          // Load existing data
          const activeBranches = JSON.parse(fs.readFileSync(`${trackingDir}/active-branches.json`, 'utf8'));
          const mergeLog = JSON.parse(fs.readFileSync(`${trackingDir}/merge-log.json`, 'utf8'));
          const cleanupQueue = JSON.parse(fs.readFileSync(`${trackingDir}/cleanup-queue.json`, 'utf8'));
          
          // Ensure repository array exists
          if (!activeBranches.branches[payload.repository]) {
            activeBranches.branches[payload.repository] = [];
          }
          
          if (payload.event === 'created' || payload.event === 'pushed') {
            // Add new branch to active tracking
            const branchData = {
              name: payload.branch,
              author: payload.author,
              created: payload.timestamp,
              lastActivity: payload.timestamp,
              taskGroup: null, // Will be assigned later if part of a task group
              status: 'active',
              changeType: payload.changeType,
              environment: payload.environment,
              worktree: `${process.env.TUVENS_PROJECT_ROOT || '~/Code/Tuvens'}/${payload.repository}/worktrees/${payload.branch}`,
              agent: determineAgent(payload.repository, payload.changeType),
              relatedBranches: [],
              githubUrl: payload.githubUrl,
              issues: []
            };
            
            // Check if branch already exists (avoid duplicates)
            const existingIndex = activeBranches.branches[payload.repository]
              .findIndex(b => b.name === payload.branch);
            
            if (existingIndex === -1) {
              activeBranches.branches[payload.repository].push(branchData);
              console.log(`✅ Added branch ${payload.branch} to tracking`);
            } else {
              console.log(`⚠️  Branch ${payload.branch} already exists in tracking`);
            }
            
          } else if (payload.event === 'merged' || payload.event === 'merged_into_dev') {
            // Move from active to merge log
            const repoIndex = activeBranches.branches[payload.repository] || [];
            const branchIndex = repoIndex.findIndex(b => b.name === payload.branch);
            
            if (branchIndex !== -1) {
              const branchData = activeBranches.branches[payload.repository][branchIndex];
              
              // Add to merge log
              mergeLog.recentMerges.unshift({
                repository: payload.repository,
                branch: payload.branch,
                targetBranch: payload.targetBranch,
                mergedAt: payload.timestamp,
                mergedBy: payload.mergedBy,
                taskGroup: branchData.taskGroup,
                cleanupEligible: true,
                worktreePath: branchData.worktree,
                changeType: branchData.changeType,
                originalAuthor: branchData.author,
                githubUrl: branchData.githubUrl,
                pullRequestUrl: payload.pullRequestUrl
              });
              
              // Add to cleanup queue (prioritize merged_into_dev)
              cleanupQueue.push({
                repository: payload.repository,
                branch: payload.branch,
                worktreePath: branchData.worktree,
                mergedAt: payload.timestamp,
                cleanupEligible: true,
                priority: payload.event === 'merged_into_dev' ? 'high' : 'normal',
                mergeTarget: payload.targetBranch
              });
              
              // Remove from active branches
              activeBranches.branches[payload.repository].splice(branchIndex, 1);
              
              if (payload.event === 'merged_into_dev') {
                console.log(`🧹 CLEANUP TRIGGER: ${payload.branch} merged into dev - added to high-priority cleanup`);
              } else {
                console.log(`✅ Moved branch ${payload.branch} from active to merge log`);
              }
            } else {
              console.log(`⚠️  Branch ${payload.branch} not found in active tracking`);
            }
            
            // Keep only last 50 merges
            if (mergeLog.recentMerges.length > 50) {
              mergeLog.recentMerges = mergeLog.recentMerges.slice(0, 50);
            }
            
          } else if (payload.event === 'deleted') {
            // Remove from active branches (if still there)
            const repoIndex = activeBranches.branches[payload.repository] || [];
            const branchIndex = repoIndex.findIndex(b => b.name === payload.branch);
            
            if (branchIndex !== -1) {
              activeBranches.branches[payload.repository].splice(branchIndex, 1);
              console.log(`✅ Removed deleted branch ${payload.branch} from active tracking`);
            }
          }
          
          // Update timestamps
          activeBranches.lastUpdated = new Date().toISOString();
          
          // Save updated data
          fs.writeFileSync(`${trackingDir}/active-branches.json`, 
            JSON.stringify(activeBranches, null, 2));
          fs.writeFileSync(`${trackingDir}/merge-log.json`, 
            JSON.stringify(mergeLog, null, 2));
          fs.writeFileSync(`${trackingDir}/cleanup-queue.json`, 
            JSON.stringify(cleanupQueue, null, 2));
          
          console.log(`✅ Updated central branch tracking for ${payload.repository}/${payload.branch}`);
          
          // Determine appropriate agent based on repository and change type
          function determineAgent(repository, changeType) {
            // Repository-based agent assignment
            const repoAgents = {
              'tuvens-client': 'svelte-dev',
              'tuvens-api': 'node-dev', 
              'hi.events': changeType === 'feature' ? 'react-dev' : 'laravel-dev',
              'eventsdigest-ai': 'svelte-dev',
              'tuvens-docs': 'vibe-coder'
            };
            
            return repoAgents[repository] || 'unknown';
          }
          EOF
          
          # Run the update script with environment variables
          EVENT_TYPE="${{ steps.payload.outputs.event }}" \
          REPOSITORY="${{ steps.payload.outputs.repository }}" \
          BRANCH="${{ steps.payload.outputs.branch }}" \
          CHANGE_TYPE="${{ steps.payload.outputs.change_type }}" \
          ENVIRONMENT="${{ steps.payload.outputs.environment }}" \
          AUTHOR="${{ steps.payload.outputs.author }}" \
          TIMESTAMP="${{ steps.payload.outputs.timestamp }}" \
          GITHUB_URL="${{ github.event.client_payload.githubUrl }}" \
          PR_URL="${{ github.event.client_payload.pullRequestUrl }}" \
          TARGET_BRANCH="${{ github.event.client_payload.targetBranch }}" \
          MERGED_BY="${{ github.event.client_payload.mergedBy }}" \
          node update-tracking.js

      - name: Generate tracking summary
        run: |
          # Create a summary of current branch state
          cat > agentic-development/branch-tracking/summary.md << EOF
          # Branch Tracking Summary
          **Generated**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Last Event**: ${{ steps.payload.outputs.event }} - ${{ steps.payload.outputs.repository }}/${{ steps.payload.outputs.branch }}
          **Event Author**: ${{ steps.payload.outputs.author }}
          
          ## Active Branches Summary
          $(node -e "
            const data = JSON.parse(require('fs').readFileSync('agentic-development/branch-tracking/active-branches.json', 'utf8'));
            Object.keys(data.branches).forEach(repo => {
              console.log(\`### \${repo}\`);
              data.branches[repo].forEach(branch => {
                console.log(\`- **\${branch.name}** (\${branch.changeType}) - \${branch.author} - \${branch.environment}\`);
              });
              console.log('');
            });
          ")
          
          ## Recent Activity
          - **Event**: ${{ steps.payload.outputs.event }}
          - **Repository**: ${{ steps.payload.outputs.repository }}
          - **Branch**: ${{ steps.payload.outputs.branch }}
          - **Change Type**: ${{ steps.payload.outputs.change_type }}
          - **Author**: ${{ steps.payload.outputs.author }}
          - **Environment**: ${{ steps.payload.outputs.environment }}
          
          ## Task Coordination
          Use this data for:
          - Cross-repository task coordination
          - Automated worktree cleanup
          - Agent assignment recommendations
          - Development context preservation
          EOF

      - name: Acquire distributed lock
        id: acquire_lock
        run: |
          # Create unique lock branch to prevent simultaneous operations
          LOCK_KEY="tracking-lock-$(date +%Y%m%d-%H%M%S)-$$"
          echo "🔐 Attempting to acquire lock: $LOCK_KEY"
          
          # Try to create lock branch atomically
          if git ls-remote --exit-code origin "refs/heads/$LOCK_KEY" >/dev/null 2>&1; then
            echo "Lock branch already exists, waiting..."
            DELAY=$((RANDOM % 60 + 30))
            sleep $DELAY
            exit 1  # Let GitHub Actions retry
          else
            # Create ephemeral lock branch
            git checkout -b "$LOCK_KEY" 2>/dev/null || true
            if git push origin "$LOCK_KEY" 2>/dev/null; then
              echo "lock_acquired=true" >> $GITHUB_OUTPUT
              echo "lock_key=$LOCK_KEY" >> $GITHUB_OUTPUT
              echo "✅ Lock acquired: $LOCK_KEY"
            else
              echo "❌ Failed to acquire lock, another process may have it"
              exit 1
            fi
          fi
          
      - name: Validate tracking data integrity  
        run: |
          echo "🔍 Validating JSON files before committing..."
          node -e "
            const fs = require('fs');
            const files = ['active-branches.json', 'merge-log.json', 'cleanup-queue.json'];
            files.forEach(file => {
              try {
                const path = \`agentic-development/branch-tracking/\${file}\`;
                const data = JSON.parse(fs.readFileSync(path, 'utf8'));
                console.log(\`✅ \${file} is valid JSON\`);
              } catch(e) {
                console.error(\`❌ \${file} is invalid: \${e.message}\`);
                process.exit(1);
              }
            });
          "
          echo "✅ All tracking files validated successfully"

      - name: Create recovery checkpoint
        run: |
          # Save current state as recovery backup
          cp agentic-development/branch-tracking/active-branches.json \
             agentic-development/branch-tracking/active-branches.backup.json 2>/dev/null || true
          cp agentic-development/branch-tracking/merge-log.json \
             agentic-development/branch-tracking/merge-log.backup.json 2>/dev/null || true
          echo "📦 Recovery checkpoints created"

      - name: Commit tracking updates
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
          git add agentic-development/branch-tracking/
          
          if git diff --staged --quiet; then
            echo "No tracking changes to commit"
          else
            git commit -m "track: ${{ steps.payload.outputs.event }} ${{ steps.payload.outputs.repository }}/${{ steps.payload.outputs.branch }} [skip ci]

            Event: ${{ steps.payload.outputs.event }}
            Repository: ${{ steps.payload.outputs.repository }}
            Branch: ${{ steps.payload.outputs.branch }}
            Change Type: ${{ steps.payload.outputs.change_type }}
            Author: ${{ steps.payload.outputs.author }}
            Triggered by: ${{ github.actor }}
            
            Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
            "
            
            # Push with retry logic to handle race conditions
            echo "🔄 Attempting to push changes..."
            for i in {1..3}; do
              if git push; then
                echo "✅ Branch tracking updated and committed"
                break
              elif [ $i -eq 3 ]; then
                echo "❌ Failed to push after 3 attempts"
                exit 1
              else
                echo "⏳ Push failed, retrying in $((i * 10)) seconds..."
                sleep $((i * 10))
                git pull --rebase || echo "Pull failed, continuing with push retry..."
              fi
            done
          fi

      - name: Create event summary
        run: |
          echo "## 🔄 Central Branch Tracking Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Event Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Event Type**: ${{ steps.payload.outputs.event }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ steps.payload.outputs.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ steps.payload.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Change Type**: ${{ steps.payload.outputs.change_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.payload.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author**: ${{ steps.payload.outputs.author }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Updated Files" >> $GITHUB_STEP_SUMMARY
          echo "- \`active-branches.json\` - Current active branches" >> $GITHUB_STEP_SUMMARY
          echo "- \`merge-log.json\` - Recently merged branches" >> $GITHUB_STEP_SUMMARY
          echo "- \`cleanup-queue.json\` - Branches ready for cleanup" >> $GITHUB_STEP_SUMMARY
          echo "- \`summary.md\` - Human-readable summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Available for" >> $GITHUB_STEP_SUMMARY
          echo "- Cross-repository task coordination" >> $GITHUB_STEP_SUMMARY
          echo "- Automated worktree cleanup" >> $GITHUB_STEP_SUMMARY
          echo "- Agent context and assignment" >> $GITHUB_STEP_SUMMARY
          echo "- Development workflow automation" >> $GITHUB_STEP_SUMMARY

      - name: Release distributed lock
        if: always() && steps.acquire_lock.outputs.lock_acquired == 'true'
        run: |
          LOCK_KEY="${{ steps.acquire_lock.outputs.lock_key }}"
          echo "🔓 Releasing lock: $LOCK_KEY"
          git push origin --delete "$LOCK_KEY" 2>/dev/null || echo "⚠️  Lock branch may have been cleaned up already"
          echo "✅ Lock released successfully"